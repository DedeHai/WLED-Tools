<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
	<meta name="author" content="@dedehai">
	<meta name="license" content="EUPL v. 1.2 or later">
	<title>WLED Pixel Paint</title>
	<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.5.2/dist/iro.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.js"></script>
	<style>
		@font-face {
			font-family: 'painter';
			src: url('data:font/woff2;charset=utf-8;base64,d09GMgABAAAAAAY4AA0AAAAAC/QAAAXiAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGhgGYACDIBEICotUiTULHgABNgIkAzgEIAWDGweBFhvTCVGULk4c4CO1K54cqNDP/3/atPuYic3HokREiGiNqJwWS1Jxmp6GVMl26Taw61BxqibIijsNMBAi9779Wt35pxoNl9RoaU50TyUhLkk0Uy0T0m1DtUEpvE6pVHojZVTNFRcOsPWcZtJeR/AqAAQAb49Y8yMAnxUUJ3NCYYgBchD5eVzNca/SEvgAojWi+wAW22noGxRSAE5NkRxMFfzcxV32XoaqdAJAAI1X/Fyi0dAAaymtNTzm/w4jIQcHAYT4r9hXhh8lP075cd6Pq35656d/f+7y/uf1AuD/id5Pw/4O2yT7W7ZZtlA2W6qUyiXHABAi0VB/cJyYfOXESUi0jwj4yxDAwxoQyOslA5UCoknoLPoYED0PQM6DUq8hiOzcfgj5cM1LsiKDhsjDFHJ5TExUdHk+z/uQ5d5tdmvd7uFP2+53PHaq8SXXR693xWzIOTDkgqv2BrPX3/IMu5R3KG6TJ3ZjrP6yU7C5K1buYPbSU56sfXnXPIlrDkQccKl7PTqPW+tWY7IBHo3LpXb2WVaHqFdsF2w7w7S85qq1ZF2n0NV07GL2HaGazMo1iLPiYjMspwWpbS+RdR+T2c+YneHdTpmejA7v85zvd0ILsc05WG1dRT5WD2N2FyAhbjOGPIbI8oQJQ54RZ32qKRiNusedPB4McZltaqezy4NF43LlMbvO48kjq9btzgqTLAOigk2KkhVZRvbxucz2J7CsD9+tuuzsutN33xZso849lmVwnGOzD7iKY7YoDzsbPPduuutO3EorXczuUHg8OrPtPHjtqrMCv4NlTWjnyh1MYt+l0K3bRmQ9iNRuCCAXd59HBc5LizXL4WD2OxmOXSfimO4CLJvD1evv74fdzexau5G2GfuJ0CUcmEsCWG8CgLNKAr8Ir0lWpai6TbW1RqMhx2nUUD/ra7OZdGvX6hcWF+uLY3JZKDeGI0IL9Rl96P+4r1+IkZjN21SX0Rrpt1QpZK9b15j9w/slcaKB6zsyJsiYNUGFv4ZltgR1tYzSNeoCTf4u7v+B8q4/b/PTW2e01n6T9kbq6/jsqvDy5NbW/lLGSvt32RBDPRPqDWoF02yBzTaV6Z/F2Kx+8eQGacNksalMXGaqYHiJsZcM505+maFgeFCvQhZ2SuFV9J7vdCpMhuo5hG2GSx8t0KWnGmXRwQLo1Pr0lLtlXzvc/W7xnOL0q59xflxKUVNz8ani/dSi4NKi5qZipMtt76RqUjNXy5jf/U7N2LE179SOSaTGWyuxEDUrpaUyuip6/Hg0VzW3RAtYsCANtTQXuw8FLJjtGTOj+WRvd2J7QrvJRJoTu7vbgcWqIiyi0+dHtcr/AJQfO5V2PV3x9wqpJKb15c6pu1a/ndw4uach8dKr05q+6wj1a5vaMuRbP3FiQX19UtKQxoqm6s5//qn6Wz00iP1Tnjy6v3QMh7BPjHFrY6H9BgTFrosRm6a8nXzg+8C14qFZRU+nGqLnhf2sUHgVQUlRdVFRNVEpwUVxC+Jj98SVBtXFbYhrHKLWD5mvsvDRyQU3bsjietJm/uhf0thSPC9hYKDoycsHUtcmvV/xTvLTb8MHqzWDQzr/Kh+s0Qzhl6e8G/Tu9j4ahEZG+PZb1SuvjZEN/s2f8bjwY8F7ii/gLgPwN0ek9WIrBPiiANtLaAyQ8jhBGgCXmmIL36UqBcPO9jlYuYQzgtdzChx1op9P6LqYfxsOgmo7/CCfBpEgHTiBCniBvtgHDM8V+8IPK9gCIvEUHIgPAJ39AIgE4cAJlMALGop9EIaxxb6Q4uUHCijCevSYoE+vPn2M0HPt/jl9RmC4SQzmmGacmfAmiZtBzBp9jbUmmWmWnvnxyEculMAdKwfMz1XG0zpt9mzxMJjEODf3OCAPm5hGjzdXPBrjBa2ZXOARpGW3ujONE/r+mMdDACI0nyAFSAQRceCIJx/yJT/ypwASiJHYb46xR2kOzuUbasuVVdKSUkOdUlkjLymTl1bLykv0+TVVsrrqTEFxJQA=') format('woff2');
		}


		html { touch-action: manipulation; }
		body {
			font-family: Verdana, sans-serif;
			font-size: 1rem;
			text-align: center;
			background: #222;
			color: #fff;
			line-height: 200%;
			margin: 0 auto;
			padding: 8px;
			max-width: 900px;
			box-sizing: border-box;
		}
		body.mode-1d { max-width: none; }
		*, *::before, *::after { box-sizing: border-box; }

		button, .btn {
			background: #333;
			color: #fff;
			font-family: Verdana, sans-serif;
			border: 0.3ch solid #333;
			border-radius: 24px;
			font-size: 20px;
			margin: 2px 2px;
			padding: 8px 12px;
			min-width: 48px;
			cursor: pointer;
			transition: all 0.3s ease;
		}
		button:hover, .btn:hover { background: #555; border-color: #555; }
		button:disabled { background: #222; color: #666; cursor: not-allowed; }
		input, select {
			background: #333;
			color: #fff;
			font-family: Verdana, sans-serif;
			border: 0.5ch solid #333;
			font-size: medium;
			margin: 2px;
		}
		input[type="number"] { width: 5em; }

		.title {
			font-size: 28px;
			font-weight: bold;
			padding: 12px 0;
			margin-bottom: 12px;
		}
		.title .rb {
			font-size: 32px;
			font-weight: bold;
			background: repeating-linear-gradient(90deg, #ff6b6b 0 6px, #feca57 6px 12px, #48dbfb 12px 18px, #7b47db 18px 24px);
			background-size: 24px 24px;
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			animation: pixshift 8s steps(15) infinite;
		}
		@keyframes pixshift { to { background-position: 24px 24px; } }

		.matrix-controls {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			justify-content: center;
			align-items: center;
		}
		.matrix-controls .size-inputs { display: flex; align-items: center; gap: 6px; }
		.matrix-controls button { margin: 0; padding: 6px 12px; font-size: 16px; min-width: 40px; }

		.main-content { display: flex; flex-direction: column; align-items: center; gap: 16px; }
		.controls-section { display: flex; justify-content: center; align-items: stretch; gap: 12px; padding: 0 4px; }
		#iroPicker { flex-shrink: 1; min-width: 200; }
		.tools-container { display: flex; flex-direction: column; flex-shrink: 1; min-width: 0; }
		.tools { display: grid; grid-template-columns: repeat(2, 1fr); gap: 3px; flex: 1; align-content: start; }
		.tool-btn {
			font-family: 'painter';
			aspect-ratio: 1;
			background: #333;
			border: 2px solid #666;
			border-radius: 14px;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			font-size: 18px;
			padding: 0;
		}
		.tool-btn.selected { background: #08d; color: #fff; border-color: #08d; }

		body.mode-1d .tool-btn.hide-1d,
		body.mode-1d .size-sep,
		body.mode-1d #matrixH { display: none; }

		body.mode-1d .led-count-1d { display: inline !important; }

		.sliders { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 600px; padding: 0 4px; margin: 0 auto 16px; }
		.slider-row { display: flex; align-items: center; gap: 8px; }
		.slider-row .slider { flex: 1; accent-color: #08d; height: 6px; min-width: 60px; }
		.slider-row label { font-size: 13px; white-space: nowrap; min-width: 50px; order: 3; }
		.slider-row .value { font-size: 13px; min-width: 30px; text-align: right; font-weight: bold; color: #08d; order: 2; }

		.canvas-container { width: 100%; max-width: 600px; margin: 0 auto 16px; padding: 0 4px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
		body.mode-1d .canvas-container { max-width: none; }

		.prev-1d-container { width: 100%; display: none; }
		.prev-1d-container.visible { display: block; }
		.prev-1d-label { font-size: 14px; color: #aaa; margin-bottom: 4px; }

		body.mode-1d #prev1DCont {
			position: sticky;
			top: 0;
			z-index: 20;
			background: #222;
		}

		#canvPrev1D {
			border: 2px solid #08d;
			background: #111;
			width: 100%;
			height: 40px;
			touch-action: none;
			image-rendering: pixelated;
		}

		.wrapped-rows-container { width: 100%; display: none; flex-direction: column; gap: 20px; }
		.wrapped-rows-container.visible { display: flex; }
		.row-canvas-wrapper { width: 100%; cursor: pointer; }
		.row-canvas-wrapper canvas {
			border: 1px solid #666;
			background: #111;
			touch-action: none;
			image-rendering: pixelated;
			display: block;
		}

		#canv {
			border: 2px solid #fff;
			background: #111;
			max-width: 100%;
			max-height: 60vh;
			width: auto;
			height: auto;
			touch-action: none;
		}
		#canv.hidden { display: none; }

		.tools-wrapper { display: flex; flex-direction: column; gap: 16px; }
		#status { padding: 6px 16px; border-radius: 20px; background: #a00; font-size: 14px; }

		.upload-section { margin: 20px 0; padding: 0 4px; }
		.filename-input { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center; margin-bottom: 12px; }
		.filename-input input[type="text"] { max-width: 200px; padding: 6px 10px; }

		@media (min-aspect-ratio: 4/3) and (min-width: 600px) {
			body:not(.mode-1d) .main-content { flex-direction: row; align-items: flex-start; justify-content: center; gap: 16px; }
			body:not(.mode-1d) .canvas-container { order: 2; margin: 0; max-width: none; flex: 1; min-width: 0; padding: 0; }
			#canv { max-height: 85vh; }
			body:not(.mode-1d) .tools-wrapper { order: 1; width: 300px; flex-shrink: 0; }
			body:not(.mode-1d) .controls-section { flex-direction: row; align-items: center; margin-bottom: 16px; }
			body:not(.mode-1d) .sliders { max-width: none; margin: 0; }
			.tool-btn { font-size: 20px; }
			.tools { row-gap: 4px; column-gap: 8px; }
		}

		@media (pointer: coarse) {
			body.mode-1d .row-canvas-wrapper canvas { height: 40px !important; }
			body.mode-1d #canvPrev1D { height: 50px !important; }
		}
	</style>
</head>
<body>
	<div style="position:absolute;top:0px;left:10px;font-size:10px;color:#666;">v1.1</div>
	<div class="title">WLED <span class="rb">PIXEL</span> Paint</div>
	<div class="matrix-controls">
		<h3>Target Segment</h3>
		<select id="seg"><option value="0" data-w="16" data-h="16">Segment 0 (16x16)</option></select>
		<div class="size-inputs">
			<span class="led-count-1d" style="display:none;">LEDs: </span>
			<input type="number" id="matrixW" value="64">
			<span class="size-sep">&times;</span>
			<input type="number" id="matrixH" value="64">
		</div>
		<div>
			<button onclick="togglePreview()" title="Live Preview" id="status">Preview Off</button>
		</div>
		<div><input type="checkbox" id="frz" checked> Freeze Segment</div>
	</div>
	<div style="margin-top: 16px; margin-bottom: 16px;">
		<button onclick="openImage()" title="Open Image" class="tool-btn action"><span>&#xf07c;</span></button>
		<input type="file" id="imgFile" accept="image/*" style="display:none">
		<button onclick="clearMatrix()" title="Clear" class="tool-btn"><span>&#xf00d;</span></button>
		<button onclick="undo()" title="Undo" class="tool-btn"><span>&#xe967;</span></button>
		<button onclick="redo()" title="Redo" class="tool-btn"><span style="display: inline-block; transform: scaleX(-1);">&#xe967;</span></button>
	</div>
	<div class="main-content">
		<div class="tools-wrapper">
			<div class="controls-section">
				<div id="iroPicker"></div>
				<div class="tools-container">
					<div class="tools" id="tools"></div>
				</div>
			</div>
			<div class="sliders">
				<div class="slider-row">
					<input type="range" id="sizeSlider" min="1" max="10" step="0.1" value="1" class="slider">
					<span class="value" id="brushSizeLabel">1.0</span>
					<label>Size</label>
				</div>
				<div class="slider-row">
					<input type="range" id="hardnessSlider" min="1" max="100" value="100" class="slider">
					<span class="value" id="brushHardnessLabel">100</span>
					<label>Hard</label>
				</div>
			</div>
		</div>
		<div class="canvas-container">
			<div class="prev-1d-container" id="prev1DCont">
				<div class="prev-1d-label">Full Strip</div>
				<canvas id="canvPrev1D"></canvas>
			</div>
			<div class="prev-1d-label">Detail View</div>
			<div class="wrapped-rows-container" id="wrapRowCont"></div>
			<div class="wrapped-canvas-container">
				<canvas id="canv"></canvas>
			</div>
		</div>
	</div>
	<div class="upload-section" id="uploadSect">
		<div class="upload">
			<div class="filename-input">
				<label for="fn">Name:</label>
				<input type="text" id="fn" placeholder="mypaint" maxlength="20">
			</div>
			<button class="btn" id="savePreset" onclick="savePreset()">Save as Preset</button>
			<button class="btn" id="saveGIF" onclick="saveGIF()">Save as GIF</button>
		</div>
	</div>
	<div style="text-align:center;margin:20px 0">
		<button class="btn" onclick="window.location.href=wu">Back to Controls</button>
	</div>
	<div style="font-size:12px;color:#666;">by @dedehai</div>
	<script>
		const PIXEL_SIZE = 32, DEFAULT_MATRIX = 64, MIN_MATRIX = 1, MAX_LEDS = 4096, MAX_MATRIX = 128;
		const LED_PX_SIZE = 16, ROW_HEIGHT = 24; // 1D size
		const TOOLS = [
			{name:"Line",    icon: "&#xf068;"},  // minus/draw line f068
			{name:"Rect",    icon: "&#xf096;"},  // square f096
			{name:"Circle",  icon: "&#xf1db;"},  // circle f1db
			{name:"Fill",    icon: "&#xe90b;"},  // fill e90b
			{name:"Rainbow", icon: "ðŸŒˆ"},       // rainbow emoji
			{name:"Brush",   icon: "&#xf1fc;"},  // paintbrush f1fc
			{name:"Smear",   icon: "&#xf25a;"},  // smear hand f25a
		];

		TOOLS.forEach((t,i)=>{
			const btn = document.createElement("button");
			btn.className = "tool-btn" + (i==5?" selected":"") + (i<3?" hide-1d":"");
			btn.innerHTML = t.icon;
			btn.title = t.name;
			btn.onclick = ()=>{
				document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove("selected"));
				btn.classList.add("selected");
				tool = i;
			};
			document.getElementById("tools").appendChild(btn);
		});

		const canv = document.getElementById("canv"), ctx = canv.getContext("2d");
		const canvPrev1D = document.getElementById("canvPrev1D"), ctxPrev1D = canvPrev1D.getContext("2d");
		const mW = document.getElementById("matrixW"), mH = document.getElementById("matrixH");
		const statusEl = document.getElementById("status"), wrapRowCont = document.getElementById("wrapRowCont");
		const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
		let w = DEFAULT_MATRIX, h = DEFAULT_MATRIX, matrix = [], segs = [], curSeg = null;
		let painting = false, tool = 5, startPt = null, lastPos = null, preview = null;
		let iroPicker, brushSize = 1, brushHard = 100, hue = 0;
		let undoStack = []; let redoStack = [];
		let ws = null, prvEn = false, maxColInd = null, prvTmr = null;
		let lastSentMtx = [], wu = '', loc = false, snapMtx = null;
		let is1D = false, wrapW = 50, rowCanv = [], selRow = 0;
		let offCanv = document.createElement('canvas'), offCtx = offCanv.getContext('2d'); // off-screen canvas that hold the actual pixel data
		let globalBri = null;

		const c2h = (r,g,b)=>((r<<16)|(g<<8)|b).toString(16).padStart(6,'0').toUpperCase(); // rgb to hex
		//const h2c = h=>{const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:0,g:0,b:0};};

		// init function, reads current segements and puts them in the select list
		(async()=>{
			wu = `http://${new URLSearchParams(window.location.search).get('host') || window.location.host}`;
			const s1 = document.getElementById('seg');
			try {
				const r = await fetch(`${wu}/json/state`), j = await r.json();
				globalBri = j.bri || 128;
				segs = j.seg || [];
				s1.innerHTML = '';
				if (segs.length) {
					segs.forEach(seg => {
						const {id,n,start,stop,startY,stopY,grp,spc} = seg;
						const o = new Option(n || `Segment ${id}`, id);
						const g = grp || 1, s = spc || 0;
						const physH = stopY - startY;
						o.dataset.w = Math.ceil((stop - start) / (g + s));
						o.dataset.h = physH > 1 ? Math.ceil(physH / (g + s)) : 1;
						o.dataset.segData = JSON.stringify(seg);
						s1.add(o);
					});
				} else {
					const o = new Option('Segment 0', 0);
					o.dataset.w = 16; o.dataset.h = 16;
					o.dataset.segData = JSON.stringify({id:0,start:0,stop:16,len:16,grp:1,spc:0,of:0,on:true,bri:255,bm:0,rev:false});
					s1.add(o);
				}
				const o = s1.options[s1.selectedIndex];
				if (o) { mW.value = o.dataset.w || 16; mH.value = o.dataset.h || 16; updateMatrix(); }
			} catch(e) { console.error(e); }
		})();

		iroPicker = new iro.ColorPicker("#iroPicker", {width:168, color:"#ff6600", layout:[{component:iro.ui.Wheel},{component:iro.ui.Slider,options:{sliderType:'value'}}]});

		document.getElementById("sizeSlider").oninput = e=>{
			brushSize = parseFloat(e.target.value);
			document.getElementById("brushSizeLabel").textContent = brushSize.toFixed(1);
		};
		document.getElementById("hardnessSlider").oninput = e=>{
			brushHard = +e.target.value;
			document.getElementById("brushHardnessLabel").textContent = brushHard;
		};

		// update if selected segment changes
		document.getElementById('seg').onchange = async e=>{
			const o = e.target.selectedOptions[0];
			mW.value = o.dataset.w; mH.value = o.dataset.h;
			updateMatrix();
			if (prvEn) {
				if (curSeg) await reqJson({seg:{id:curSeg.id,frz:false}});
				const segId = +e.target.value;
				curSeg = segs.find(s=>s.id===segId)||{id:segId,start:0};
				await reqJson({seg:{id:curSeg.id,frz:true}});
				lastSentMtx = new Array(w*h).fill(null);
				await sendDirty();
			}
		};

		function updateMatrix() {
			is1D = +mH.value <= 1;

			if (is1D) {
				w = Math.max(MIN_MATRIX, Math.min(MAX_LEDS, +mW.value));
				h = 1;
				document.body.classList.add('mode-1d');
				mW.disabled = true;
				mH.disabled = true;
				document.getElementById('prev1DCont').classList.add('visible');
				document.querySelectorAll('.prev-1d-label').forEach(e=>e.style.display='block');
				wrapRowCont.classList.add('visible');
				canv.classList.add('hidden');
				canvPrev1D.width = w;
				canvPrev1D.height = 1;
				offCanv.width = w;
				offCanv.height = 1;
				createRowCanv();
			} else {
				w = Math.max(MIN_MATRIX, Math.min(MAX_MATRIX, +mW.value));
				h = Math.max(1, Math.min(MAX_MATRIX, +mH.value));
				mW.value = w; mH.value = h; // input fields
				document.body.classList.remove('mode-1d');
				mW.disabled = false;
				mH.disabled = false;
				document.getElementById('prev1DCont').classList.remove('visible');
				document.querySelectorAll('.prev-1d-label').forEach(e=>e.style.display='none');
				wrapRowCont.classList.remove('visible');
				canv.classList.remove('hidden');
				offCanv.width = w;
				offCanv.height = h;
			}

			canv.width = w * PIXEL_SIZE;
			canv.height = h * PIXEL_SIZE;
			canv.style.aspectRatio = `${w}/${h}`;

			const sz = w * h;
			if (matrix.length != sz) matrix = Array.from({length: sz}, () => ({r:0,g:0,b:0}));
			drawAll();
		}
		mW.onchange = mH.onchange = updateMatrix; // user input: update matrix size

		// create 1D detail painting rows
		function createRowCanv(){
			wrapRowCont.innerHTML='';
			rowCanv=[];	  const contW=(wrapRowCont.offsetWidth||800)-(isTouch?48:0);
			const optW=Math.floor(contW/LED_PX_SIZE);
			wrapW=Math.max(10,Math.min(200,optW));
			const numRows=Math.ceil(mW.value/wrapW);

			for(let ri=0;ri<numRows;ri++){
				const si=ri*wrapW;
				const ei=Math.min(si+wrapW,mW.value);
				const rw=ei-si;

				const wrap=document.createElement('div');
				wrap.className='row-canvas-wrapper';
				wrap.style.position='relative';
				if(ri===0)wrap.classList.add('selected');

				// Add pixel number label
				const label=document.createElement('div');
				label.style.cssText='font-size:10px;color:#999;display:flex;justify-content:space-between;padding:0 2px;position:absolute;top:-24px;left:0;right:0;pointer-events:none;width:'+(rw*LED_PX_SIZE)+'px;';
				label.innerHTML=`<span>${si}</span><span>${ei-1}</span>`;
				wrap.appendChild(label);

				const cv=document.createElement('canvas');
				cv.width=rw*LED_PX_SIZE;
				cv.height=LED_PX_SIZE;
				cv.style.width=(rw*LED_PX_SIZE)+'px';
				cv.style.height=ROW_HEIGHT+'px';
				const c=cv.getContext('2d');
				c.imageSmoothingEnabled=false;

				// paint immediately on pointerdown in any row
				cv.onpointerdown=e=>{
					selRow=ri;
					rowCanv.forEach((r,i)=>r.wrap.classList.toggle('selected',i===ri));
					startPaint(e,'row');
				};
				cv.onpointermove=e=>{e.preventDefault();if(painting&&selRow===ri)paint(e,'row');};
				cv.onpointerleave=()=>{preview=lastPos=null;drawAll();};
				wrap.appendChild(cv);
				wrapRowCont.appendChild(wrap);
				rowCanv.push({canv:cv,ctx:c,si,ei,wrap});
			}
			selRow=0;
			drawAll();
		}

		// update detail-rows when window size changes so they always fit
		let resizeTmr;
		window.addEventListener('resize', ()=>{
			if (!is1D) return;
			clearTimeout(resizeTmr);
			resizeTmr = setTimeout(()=>{
				const oldSel = selRow; createRowCanv();
				if (oldSel < rowCanv.length) selRow = oldSel;
			}, 100);
		});

		// coordinate transfrmations to match different canvas sizes
		function getCoord(e,mode){
			if(mode==='1d'){
				const rect=canvPrev1D.getBoundingClientRect();
				const scX=canvPrev1D.width/rect.width;
				const idx=Math.floor((e.clientX-rect.left)*scX);
				return{idx:Math.max(0,Math.min(mW.value-1,idx))};
			}
			if(mode==='row'){
				const row=rowCanv[selRow];
				const rect=row.canv.getBoundingClientRect();
				const clickX=e.clientX-rect.left;
				const rw=row.ei-row.si;
				const px=Math.floor((clickX/rect.width)*rw);
				return{idx:row.si+Math.max(0,Math.min(rw-1,px))};
			}
			const rect=canv.getBoundingClientRect(),scX=canv.width/rect.width,scY=canv.height/rect.height;
			return{x:Math.floor((e.clientX-rect.left)*scX/PIXEL_SIZE),y:Math.floor((e.clientY-rect.top)*scY/PIXEL_SIZE)};
		}

		function drawAll() {
			if (is1D) {
				offCtx.fillStyle = "#111"; offCtx.fillRect(0,0,w,1);
				for (let i=0;i<w;i++){const c=matrix[i];offCtx.fillStyle=`rgb(${c.r},${c.g},${c.b})`;offCtx.fillRect(i,0,1,1);}
				ctxPrev1D.imageSmoothingEnabled=false;
				ctxPrev1D.drawImage(offCanv,0,0,canvPrev1D.width,canvPrev1D.height);
				rowCanv.forEach(r=>{
					const c=r.ctx,cv=r.canv; c.fillStyle="#111"; c.fillRect(0,0,cv.width,cv.height);
					for(let i=r.si;i<r.ei;i++){const col=matrix[i];c.fillStyle=`rgb(${col.r},${col.g},${col.b})`;c.fillRect((i-r.si)*LED_PX_SIZE,0,LED_PX_SIZE,cv.height);}
					c.strokeStyle='#666'; c.lineWidth=1; c.beginPath();
					for(let i=1;i<(r.ei-r.si);i++){const x=i*LED_PX_SIZE; c.moveTo(x,0); c.lineTo(x,cv.height);}
					c.stroke();
				});
				return;
			}
			offCtx.fillStyle="#111"; offCtx.fillRect(0,0,w,h);
			const imgData=offCtx.createImageData(w,h);
			const data=imgData.data;
			for(let i=0;i<w*h;i++){
				const c=matrix[i];
				const idx=i*4;
				data[idx]=c.r;
				data[idx+1]=c.g;
				data[idx+2]=c.b;
				data[idx+3]=255;
			}
			offCtx.putImageData(imgData,0,0);

			ctx.imageSmoothingEnabled=false; ctx.drawImage(offCanv,0,0,canv.width,canv.height);
			if(preview){
				ctx.strokeStyle='rgba(255,255,255,0.8)';
				ctx.lineWidth=Math.max(1,brushSize*PIXEL_SIZE/4);
				const sx=preview.start.x*PIXEL_SIZE+PIXEL_SIZE/2, sy=preview.start.y*PIXEL_SIZE+PIXEL_SIZE/2;
				const ex=preview.end.x*PIXEL_SIZE+PIXEL_SIZE/2, ey=preview.end.y*PIXEL_SIZE+PIXEL_SIZE/2;
				ctx.beginPath();
				if(preview.tool===0){ctx.moveTo(sx,sy);ctx.lineTo(ex,ey);}
				else if(preview.tool===1){const x1=Math.min(sx,ex),y1=Math.min(sy,ey);ctx.rect(x1,y1,Math.max(sx,ex)-x1,Math.max(sy,ey)-y1);}
				else if(preview.tool===2){ctx.ellipse((sx+ex)/2,(sy+ey)/2,Math.abs(ex-sx)/2,Math.abs(ey-sy)/2,0,0,2*Math.PI);}
				ctx.stroke();
			}
			ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; ctx.beginPath();
			for(let i=1;i<w;i++){const px=i*PIXEL_SIZE;ctx.moveTo(px,0);ctx.lineTo(px,canv.height);}
			for(let j=1;j<h;j++){const py=j*PIXEL_SIZE;ctx.moveTo(0,py);ctx.lineTo(canv.width,py);}
			ctx.stroke();
		}

		function setPx(x,y,col,op=1,draw=true){
			if(x<0||x>=w||y<0||y>=h)return;
			const i=y*w+x,o=matrix[i];
			matrix[i]={r:Math.round((1-op)*o.r+op*col.r),g:Math.round((1-op)*o.g+op*col.g),b:Math.round((1-op)*o.b+op*col.b)};
			if(draw)drawAll();
		}

		function getPx(x,y){
			return matrix[Math.max(0,Math.min(h-1,y))*w+Math.max(0,Math.min(w-1,x))];
		}

		function colorDist(c1,c2){
			const dr=c1.r-c2.r,dg=c1.g-c2.g,db=c1.b-c2.b;
			return Math.sqrt(dr*dr+dg*dg+db*db);
		}

		function saveState(){
			undoStack.push(matrix.map(c=>({r:c.r,g:c.g,b:c.b})));
			if(undoStack.length>50)undoStack.shift(); // fixed undo stack size of 50 to not use excessive RAM on the device
			redoStack = []; // clear redo stack on new action
		}

		function undo(){
			if(undoStack.length){
				redoStack.push(matrix.map(c=>({r:c.r,g:c.g,b:c.b})));
				matrix=undoStack.pop();
				drawAll();
				if(prvEn) sendDirty();
			}
		}

		function redo(){
			if(redoStack.length){
				undoStack.push(matrix.map(c=>({r:c.r,g:c.g,b:c.b})));
				matrix=redoStack.pop();
				drawAll();
				if(prvEn) sendDirty();
			}
		}

		function applyBrush(x,y,col,draw,rainbow){
			if(rainbow){
				let hsv = iro.Color.rgbToHsv(col);
				hue += 1 / brushSize;
				hsv.h = hue;
				col = iro.Color.hsvToRgb(hsv);
			}
			const rad=Math.ceil(brushSize);
			const mult=brushHard*0.01; // 0.01 to 1.0
			if(is1D){
				const idx=y*w+x;
				for(let di=-rad;di<=rad;di++){
					const d=Math.abs(di);
					if(d>brushSize)continue;
					const i=idx+di;
					if(i<0||i>=mW.value)continue;
					const fall=1-d/brushSize;
					const o=matrix[i];
					const op=fall*mult;
					matrix[i]={r:Math.round((1-op)*o.r+op*col.r),g:Math.round((1-op)*o.g+op*col.g),b:Math.round((1-op)*o.b+op*col.b)};
				}
			}else{
				for(let dx=-rad;dx<=rad;dx++){
					for(let dy=-rad;dy<=rad;dy++){
						const d=Math.sqrt(dx*dx+dy*dy);
						if(d>brushSize)continue;
						const fall=1-d/brushSize;
						setPx(x+dx,y+dy,col,fall*mult,false);
					}
				}
			}
			if(draw)drawAll();
		}

		function clearMatrix(){
			matrix=Array.from({length:w*h},()=>({r:0,g:0,b:0}));
			drawAll();
			if(prvEn) sendDirty(); // send full frame update
		}

		// toggle live preview on LEDs
		async function togglePreview(){
			prvEn=!prvEn;
			statusEl.textContent=prvEn?"Preview On":"Preview Off";
			statusEl.style.background=prvEn?"#08d":"#a00";
			if(prvEn){
				reqJson({seg:{frz:true}});
				initWS();
				lastSentMtx=new Array(w*h).fill(null);
				const segId=+document.getElementById('seg').value;
				curSeg=segs.find(s=>s.id===segId)||{id:segId,start:0};
				await sendDirty(); // send full frame
			}else{
				reqJson({seg:{frz:false}});
				if(prvTmr)clearTimeout(prvTmr);
				prvTmr=curSeg=null;
			}
		}

		function startPaint(e,mode){
			e.preventDefault();
			painting=true;
			const coord=getCoord(e,mode);
			startPt=lastPos=coord;
			saveState(); // save state for undo
			snapMtx=matrix.map(c=>({r:c.r,g:c.g,b:c.b}));
			paint(e,mode);
			if(prvEn&&!prvTmr)paintCmp(); // start scheduler to monitor pixel changes and send them out
		}

		canv.addEventListener('pointerdown',e=>startPaint(e,'2d'));
		canv.addEventListener('pointermove',e=>{e.preventDefault();if(painting)paint(e,'2d');});
		canv.addEventListener('pointerleave',()=>{preview=lastPos=null;drawAll();});

		canvPrev1D.addEventListener('pointerdown',e=>startPaint(e,'1d'));
		canvPrev1D.addEventListener('pointermove',e=>{e.preventDefault();if(painting)paint(e,'1d');});
		canvPrev1D.addEventListener('pointerleave',()=>{lastPos=null;drawAll();});

		document.addEventListener('pointerup',endPaint);

		async function endPaint(){
			const wasPaint=painting;
			if(painting&&preview&&!is1D){
				if(preview.tool===0)applyLine(preview.start.x,preview.start.y,preview.end.x,preview.end.y,iroPicker.color.rgb);
				else if(preview.tool===1)applyRect(preview.start.x,preview.start.y,preview.end.x,preview.end.y,iroPicker.color.rgb);
				else if(preview.tool===2)applyCircle(preview.start.x,preview.start.y,preview.end.x,preview.end.y,iroPicker.color.rgb);
				preview=null;
				drawAll();
			}
			painting=false;
			startPt=lastPos=null;
			if(wasPaint&&prvEn){
				setTimeout(async()=>{
					const diff=[];
					for(let i=0;i<matrix.length;i++){
						const o=snapMtx[i],n=matrix[i];
						if(o.r!==n.r||o.g!==n.g||o.b!==n.b)diff.push({idx:i,hex:c2h(n.r,n.g,n.b)});
					}
					if(diff.length)await sendDirty(diff); // first pass: send diff between now and before painting
				},80); // let the paint dry first ;)
				setTimeout(async()=>{
					await sendDirty(); // second pass: update the full frame in case something went wrong
				},300);
			}
		}

		function paint(e,mode){
			const coord=getCoord(e,mode);
			const col=iroPicker.color.rgb;
			const px=coord.idx!==undefined?coord.idx%w:coord.x;
			const py=coord.idx!==undefined?Math.floor(coord.idx/w):coord.y;
			let rainbow = false;
			switch(tool){
				case 0:
				case 1:
				case 2: // circle,rect,line not available in 1D mode
					if(startPt&&!is1D){preview={tool,start:startPt,end:coord};drawAll();}
					break;
				case 3:
					floodFill(px,py,col);
					break;
				case 4: // rainbow
					rainbow = true;
				 // fall through
				case 5: // brush
					if(lastPos){
						const lx=lastPos.idx!==undefined?lastPos.idx%w:lastPos.x;
						const ly=lastPos.idx!==undefined?Math.floor(lastPos.idx/w):lastPos.y;
						if(lx!==px||ly!==py){
							const dx=px-lx,dy=py-ly,steps=Math.max(1,Math.ceil(Math.sqrt(dx*dx+dy*dy)));
							for(let i=0;i<=steps;i++)applyBrush(Math.round(lx+dx*i/steps),Math.round(ly+dy*i/steps),col,false,rainbow);
							drawAll();
						}else applyBrush(px,py,col,true,rainbow);
					}else applyBrush(px,py,col,true,rainbow);
					lastPos=coord;
					break;
				case 6: // smear
					if(lastPos){
						const lx=lastPos.idx!==undefined?lastPos.idx%w:lastPos.x;
						const ly=lastPos.idx!==undefined?Math.floor(lastPos.idx/w):lastPos.y;
						if(lx!==px||ly!==py){
							const dx=px-lx,dy=py-ly,steps=Math.max(1,Math.ceil(Math.sqrt(dx*dx+dy*dy)));
							const rad=Math.ceil(brushSize);
							for(let i=0;i<=steps;i++){
								const cx=Math.round(lx+dx*i/steps),cy=Math.round(ly+dy*i/steps);
								for(let ddx=-rad;ddx<=rad;ddx++){
									for(let ddy=-rad;ddy<=rad;ddy++){
										const d=Math.sqrt(ddx*ddx+ddy*ddy);
										if(d>brushSize)continue;
										const op=(1-d/brushSize)*(0.3+brushHard/100*0.7);
										setPx(cx+ddx,cy+ddy,getPx(lx+ddx,ly+ddy),op,false);
									}
								}
							}
							drawAll();
						}
					}
					lastPos=coord;
					break;
			}
		}

		function applyLine(x0,y0,x1,y1,col){
			let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0),sx=x0<x1?1:-1,sy=y0<y1?1:-1,err=dx-dy;
			while(true){
				applyBrush(x0,y0,col,false);
				if(x0==x1&&y0==y1)break;
				const e2=2*err;
				if(e2>-dy){err-=dy;x0+=sx;}
				if(e2<dx){err+=dx;y0+=sy;}
			}
			drawAll();
		}

		function floodFill(x,y,col){
			const thresh=(brushSize/10)*25,tgt=getPx(x,y);
			if(colorDist(tgt,col)<thresh)return;
			let vis=new Uint8Array(w*h),stack=[[x,y]];
			while(stack.length){
				let[cx,cy]=stack.pop();
				if(cx<0||cx>=w||cy<0||cy>=h)continue;
				let i=cy*w+cx;
				if(vis[i])continue;
				vis[i]=1;
				if(colorDist(getPx(cx,cy),tgt)>thresh)continue;
				setPx(cx,cy,col,brushHard/100,false);
				stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
			}
			drawAll();
		}

		function applyRect(x0,y0,x1,y1,col){
			let xmin=Math.min(x0,x1),xmax=Math.max(x0,x1),ymin=Math.min(y0,y1),ymax=Math.max(y0,y1);
			for(let x=xmin;x<=xmax;x++){applyBrush(x,ymin,col,false);applyBrush(x,ymax,col,false);}
			for(let y=ymin+1;y<ymax;y++){applyBrush(xmin,y,col,false);applyBrush(xmax,y,col,false);}
			drawAll();
		}

		function applyCircle(x0,y0,x1,y1,col){
			const cx=(x0+x1)/2,cy=(y0+y1)/2,rx=Math.abs(x1-x0)/2,ry=Math.abs(y1-y0)/2;
			const steps=Math.max(300,Math.ceil(2*Math.PI*Math.max(rx,ry)));
			for(let i=0;i<steps;i++){
				const a=(i/steps)*2*Math.PI;
				applyBrush(Math.round(cx+rx*Math.cos(a)),Math.round(cy+ry*Math.sin(a)),col,false);
			}
			drawAll();
		}

		function initWS(){
			if(!ws||ws.readyState!==WebSocket.OPEN)ws=connectWs();
			fetch(`${wu}/json/info`).then(r=>r.json()).then(inf=>{
				maxColInd=inf.arch==='esp8266'?35:85; // maxColInd is the maximum individual color commands that fit in WS buffer (~12 bytes per color, conservative estimate)
			}).catch(()=>{});
			if(!ws)maxColInd=256;
		}

		function connectWs(){
			try{if(top.window.ws&&top.window.ws.readyState===WebSocket.OPEN)return top.window.ws;}catch(e){}
			let url=(loc?`${wu}/ws`.replace("http","ws"):"ws://"+window.location.hostname+"/ws");
			let w=new WebSocket(url);
			w.binaryType="arraybuffer";
			w.addEventListener('close',()=>ws=null);
			w.addEventListener('error',()=>ws=null);
			return w;
		}

		// send json request over WS or HTTP
		async function reqJson(cmd){
			if(ws&&ws.readyState==1){
				try{ws.send(JSON.stringify(cmd));return 1;}catch(e){}
			}
			if(!window._httpQ){window._httpQ=[];window._httpRun=0;}
			if(_httpQ.length>=5)return -1;
			return new Promise(resolve=>{
				_httpQ.push({cmd,resolve});
				(async function run(){
					if(_httpRun)return;
					_httpRun=1;
					while(_httpQ.length){
						let q=_httpQ.shift();
						try{await fetch(`${wu}/json`,{method:'post',body:JSON.stringify(q.cmd),cache:'no-store'});}catch(e){}
						await new Promise(r=>setTimeout(r,120));
						q.resolve(0);
					}
					_httpRun=0;
				})();
			});
		}

		// sends out the pixels contained in the diffList in chunks, sends full frame update when no diffList provided
		async function sendDirty(diffList){
			if(!prvEn||!curSeg)return;
			let interval=20,isRefresh=false;
			if(!diffList){
				diffList=matrix.map((c,i)=>({idx:i,hex:c2h(c.r,c.g,c.b)}));
				interval=40;
				isRefresh=true;
			}
			if(!diffList.length)return;
			diffList.sort((a,b)=>a.idx-b.idx);
			let chunk=[];
			for(let d of diffList){
				if(d.idx>=matrix.length)continue;
				chunk.push((curSeg.start||0)+d.idx,d.hex);
				if(chunk.length>=maxColInd*2){
					if(isRefresh&&painting)return;
					await reqJson({seg:{id:curSeg.id,i:chunk}});
					chunk=[];
					await new Promise(r=>setTimeout(r,interval));
				}
			}
			if(chunk.length){
				await reqJson({seg:{id:curSeg.id,i:chunk}});
				await new Promise(r=>setTimeout(r,interval));
			}
			for(let d of diffList){
				if(d.idx<matrix.length)lastSentMtx[d.idx]=d.hex;
			}
		}

		// monitoring loop that checks for changed pixels while painting every 50ms
		function paintCmp(){
			prvTmr=setTimeout(async()=>{
				prvTmr=null;
				const diff=[];
				for(let i=0;i<matrix.length;i++){
					const c=matrix[i];
					const hex=c2h(c.r,c.g,c.b);
					if(lastSentMtx[i]!==hex)diff.push({idx:i,hex});
				}
				if(diff.length)await sendDirty(diff);
				if(painting&&prvEn)paintCmp();
			},50);
		}

		function openImage(){
			const f=document.getElementById('imgFile');
			f.value='';
			f.onchange=e=>{
				const a=e.target.files[0];
				if(!a)return;
				const i=new Image();
				i.onload=()=>{
					offCanv.width=i.width;offCanv.height=i.height;
					offCtx.drawImage(i,0,0,i.width,i.height);
					const d=offCtx.getImageData(0,0,i.width,i.height).data;
					if(is1D && (w*h == i.width*i.height || w*h == (i.width*i.height-1))){
						// for 1D mode and "matching" image size, sample pixels from image starting from top-left to bottom-right
						// note: the WLED image loader loads images for 1D the same way in 0.16+, this does not work with older versions
						let j=0;
						for(let y=0;y<i.height&&j<matrix.length;y++){
							for(let x=0;x<i.width&&j<matrix.length;x++){
								const p=(y*i.width+x)*4;
								matrix[j++]={r:d[p],g:d[p+1],b:d[p+2]};
							}
						}
						updateMatrix(); // to redraw 1D views as we changed the offCanv
					}else{
						offCanv.width=w;offCanv.height=h;
						offCtx.drawImage(i,0,0,w,h);
						const d2=offCtx.getImageData(0,0,w,h).data;
						for(let k=0;k<w*h;k++)matrix[k]={r:d2[k*4],g:d2[k*4+1],b:d2[k*4+2]};
					}
					drawAll();
					if(prvEn)sendDirty();
				};
				i.src=URL.createObjectURL(a);
			};
			f.click();
		}

		async function savePreset(e, colorReduction = 0) {
			console.log('Saving preset with color reduction:', colorReduction);
			let fn=document.getElementById('fn').value.trim()||'mypaint';
			if(colorReduction) fn+='[reduced]';
			if(!fn)return;
			const colors = [];
			const mask = (0xFF >> colorReduction) << colorReduction; // mask off lowest bit(s)
			// build color array with reduced color depth if needed: reduces json size by grouping similar colors
			for(let i = 0; i < w*h; i++){
				colors[i] = c2h(matrix[i].r & mask, matrix[i].g & mask, matrix[i].b & mask);
			}

			// build color array and optimize size using range pattern
			const pattern = [];
			let si=0,cur=colors[0];
			for (let i = 1; i <= colors.length; i++) {
				if(i===colors.length||colors[i]!==cur){
					pattern.push(...(i - si === 1 ? [cur] : [si, i, cur])); // push single color or range
					if (i < colors.length) { si = i; cur = colors[i]; }
				}
			}

			const segData = JSON.parse(document.getElementById('seg').selectedOptions[0].dataset.segData || '{}');
			try {
				const presets = await (await fetch(`${wu}/presets.json`)).json();
				const nextId = Math.max(...Object.keys(presets).map(k => parseInt(k)).filter(n => !isNaN(n)), 0) + 1;

				const res = await (await fetch(`${wu}/json`, {
					method: 'POST',
					body: JSON.stringify({
						on: true, bri: globalBri,
						seg: {
							id: segData.id || 0,
							start: segData.start || 0,
							stop: segData.stop || mW.value,
							len: segData.len || mW.value,
							grp: segData.grp || 1,
							spc: segData.spc || 0,
							of: segData.of || 0, on: true,
							frz: true, bri: segData.bri || 255,
							bm: segData.bm || 0,
							rev: segData.rev || false, i: pattern
						},
						n: fn, o: false, psave: nextId
					})
				})).json();

				if (res.success) showToast(`Preset "${fn}" saved as ID ${nextId}`);
				//if (res.success) showToast(`Preset "${fn}" saved as ID ${nextId}\n${pattern.length} elements (${colors.length} LEDs)${colorReduction ? ` (reduced ${colorReduction}x)` : ''}`); //debug
				else throw new Error(); // handle as error below
			} catch (err) {
				// lets assume the error is due to payload size (it usually is), reduce color depth and try again
				if (colorReduction < 4) { // limit max reduction to 4 bits
					showToast(`Preset too large, reducing colors`,true);
					return await savePreset(e, colorReduction + 1);
				}
				else showToast(`Error: ${err.message}`,true);
			}
		}

		// generate gif palette using median-cut algorithm, palette is padded to power of 2 size (gif standard)
		function genPal(pix){
			const map=new Map();
			for(let i=0;i<pix.length;i+=4){
				const c=(pix[i]<<16)|(pix[i+1]<<8)|pix[i+2];
				map.set(c,(map.get(c)||0)+1);
			}
			let buckets=[Array.from(map,([rgb,count])=>({r:rgb>>16&255,g:rgb>>8&255,b:rgb&255,count}))];
			while(buckets.length<256&&buckets.some(b=>b.length>1)){
				buckets.sort((a,b)=>b.length-a.length);
				const b=buckets.shift();
				const ch=['r','g','b'].map(k=>({k,range:Math.max(...b.map(c=>c[k]))-Math.min(...b.map(c=>c[k]))}))
					.reduce((a,b)=>a.range>b.range?a:b).k;
				b.sort((a,c)=>a[ch]-c[ch]);
				const m=b.length>>1;
				buckets.push(b.slice(0,m),b.slice(m));
			}
			const pal=buckets.map(b=>{
				const t=b.reduce((s,c)=>s+c.count,0);
				const r=Math.round(b.reduce((s,c)=>s+c.r*c.count,0)/t);
				const g=Math.round(b.reduce((s,c)=>s+c.g*c.count,0)/t);
				const bl=Math.round(b.reduce((s,c)=>s+c.b*c.count,0)/t);
				return(r<<16)|(g<<8)|bl;
			});
			let p2=1;
			while(p2<pal.length)p2<<=1;
			for(let i=pal.length;i<p2;i++)pal[i]=pal[pal.length-1];
			const idx=new Uint8Array(pix.length/4);
			for(let i=0,j=0;i<pix.length;i+=4,j++){
				let r=pix[i],g=pix[i+1],b=pix[i+2],best=0,min=1e9;
				for(let k=0;k<buckets.length;k++){
					const p=pal[k],pr=p>>16&255,pg=p>>8&255,pb=p&255;
					const d=(r-pr)**2+(g-pg)**2+(b-pb)**2;
					if(d<min){min=d;best=k;}
				}
				idx[j]=best;
			}
			return{indexed:idx,palette:pal};
		}

		// calculate optimal grid dimensions for 1D pixel data (gif is restricted to 320x320)
		function grid(length) {
			if (length <= 320) return { w: length, h: 1 };
			let best = [1, length], waste = length;
			// find best matching width/height with least wasted pixels (should never be more than 1)
			for (let w = 320; w >= 2; w--) {
				const h = Math.ceil(length / w);
				const wst = w * h - length;
				if (wst < waste) {
					best = [w, h];
					waste = wst;
					if (!waste) break;
				}
			}
			return { w: best[0], h: best[1] };
		}

		// generate and upload gif
		async function saveGIF() {
			let fn = document.getElementById('fn').value.trim()||'mypaint';
			if(!fn.endsWith('.gif')) fn += '.gif';
			let exists=false;
			try{
				const r=await fetch(`${wu}/edit?list=/`),data=await r.json();
				exists=data.some(f=>f.name==="/"+fn&&f.name.toLowerCase().endsWith('.gif'));
			}catch(e){console.error('Error fetching file list:',e);}
			if(exists&&!confirm(`${fn} already exists. Do you want to overwrite it?`))return;
			try{
				let gw = w, gh = h; // gif width and height
				if(is1D){
					const g = grid(w); // calculate optimal grid size
					gw = g.w; gh = g.h;
				}
				const pix=new Uint8Array(gw*gh*4);
				for(let i=0;i<gw*gh;i++){
					const c=matrix[i]||matrix[w*h-1]; // pad with last pixel if out of bounds
					pix[i*4]=c.r;pix[i*4+1]=c.g;pix[i*4+2]=c.b;pix[i*4+3]=255;
				}
				const id=new ImageData(new Uint8ClampedArray(pix),gw,gh);
				let{indexed,palette}=genPal(id.data);
				const gifData=[],wr=new window.GifWriter(gifData,gw,gh,{loop:0,palette});
				wr.addFrame(0,0,gw,gh,indexed);
				wr.end();
				const fU=new File([new Uint8Array(gifData)],fn,{type:'image/gif'});
				const fd=new FormData();
				fd.append('file',fU,fn);
				const r=await fetch(`${wu}/upload`,{method:'POST',body:fd});
				if(r.ok)showToast(`${fn} saved`);
				else showToast('Upload failed',true);
			}catch(e){showToast(`Error: ${e.message}`,true);}
		};

		// unfreeze segment when leaving the page unless freeze checkbox is checked
		window.addEventListener('beforeunload',()=>{
			if(prvEn && !document.getElementById('frz').checked) reqJson({seg:{frz:false}});
		});

		function showToast(message,e=false) {
			const toast = document.createElement('div');
			Object.assign(toast.style, {
				position: 'fixed', bottom: '20px', right: '20px',
				background: e?'#e00':'#555', color: '#fff', padding: '10px 20px',
				borderRadius: '10px', fontSize: '14px', zIndex: '1000'
			});
			toast.textContent = message;
			document.body.appendChild(toast);
			setTimeout(() => toast.remove(), 5000);
		}

		updateMatrix();
		togglePreview(); // enable preview on page load
	</script>
</body>
</html>