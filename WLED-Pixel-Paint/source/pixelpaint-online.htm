<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
	<meta name="author" content="@dedehai">
	<meta name="license" content="EUPL v. 1.2 or later">
	<title>WLED Pixel Paint</title>
	<script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5.5.2/dist/iro.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.js"></script>
	<style>
		@font-face {
			font-family: 'painter';
			src: url('data:font/woff2;charset=utf-8;base64,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') format('woff2');
		}
		html { touch-action: manipulation; }
		body {
			font-family: Verdana, sans-serif;
			font-size: 1rem;
			text-align: center;
			background: #222;
			color: #fff;
			line-height: 200%;
			margin: 0 auto;
			padding: 8px;
			max-width: 900px;
			box-sizing: border-box;
		}
		body.mode-1d { max-width: none; }
		*, *::before, *::after { box-sizing: border-box; }

		button, .btn {
			background: #333;
			color: #fff;
			font-family: Verdana, sans-serif;
			border: 0.3ch solid #333;
			border-radius: 24px;
			font-size: 20px;
			margin: 8px 4px;
			padding: 8px 12px;
			min-width: 48px;
			cursor: pointer;
			transition: all 0.3s ease;
		}
		button:hover, .btn:hover { background: #555; border-color: #555; }
		button:disabled { background: #222; color: #666; cursor: not-allowed; }

		input, select {
			background: #333;
			color: #fff;
			font-family: Verdana, sans-serif;
			border: 0.5ch solid #333;
			font-size: medium;
			margin: 2px;
		}
		input[type="number"] { width: 4em; }

		.title {
			font-size: 28px;
			font-weight: bold;
			padding: 12px 0;
			margin-bottom: 12px;
		}
		.title .rb {
			font-size: 32px;
			font-weight: bold;
			background: repeating-linear-gradient(90deg, #ff6b6b 0 6px, #feca57 6px 12px, #48dbfb 12px 18px, #7b47db 18px 24px);
			background-size: 24px 24px;
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			animation: pixshift 8s steps(15) infinite;
		}
		@keyframes pixshift { to { background-position: 24px 24px; } }

		.matrix-controls {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			justify-content: center;
			align-items: center;
			margin-bottom: 16px;
			padding: 0 4px;
		}
		.matrix-controls .size-inputs { display: flex; align-items: center; gap: 6px; }
		.matrix-controls .actions { display: flex; gap: 6px; flex-wrap: wrap; }
		.matrix-controls button { margin: 0; padding: 6px 12px; font-size: 16px; min-width: 40px; }

		.main-content { display: flex; flex-direction: column; align-items: center; gap: 16px; }
		.controls-section { display: flex; justify-content: center; align-items: stretch; gap: 12px; padding: 0 4px; }
		#iroPicker { flex-shrink: 1; min-width: 200; }
		.tools-container { display: flex; flex-direction: column; flex-shrink: 1; min-width: 0; }
		.tools { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; flex: 1; align-content: start; }
		body.mode-1d .tools { grid-template-columns: 1fr; }
		.tool-btn {
			font-family: 'painter';
			aspect-ratio: 1;
			background: #333;
			border: 2px solid #666;
			border-radius: 14px;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			font-size: clamp(16px, 3.5vw, 20px);
			transition: .3s;
			padding: 0;
		}
		.tool-btn.selected { background: #08d; color: #fff; border-color: #08d; box-shadow: 0 0 10px rgba(0,136,221,0.5); }
		.action-icon { 
			font-family: 'painter'; 
			font-size: 18px;}

		body.mode-1d .tool-btn.hide-1d,
		body.mode-1d .size-sep,
		body.mode-1d #matrixH { display: none; }

		body.mode-1d .led-count-1d { display: inline !important; }
		body.mode-1d .upload-2d { display: none !important; }
		body.mode-1d .upload-1d { display: block !important; }

		.sliders { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 600px; padding: 0 4px; margin: 0 auto 16px; }
		.slider-row { display: flex; align-items: center; gap: 8px; }
		.slider-row .slider { flex: 1; accent-color: #08d; height: 6px; min-width: 60px; }
		.slider-row label { font-size: 13px; white-space: nowrap; min-width: 50px; order: 3; }
		.slider-row .value { font-size: 13px; min-width: 30px; text-align: right; font-weight: bold; color: #08d; order: 2; }

		.canvas-container { width: 100%; max-width: 600px; margin: 0 auto 16px; padding: 0 4px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
		body.mode-1d .canvas-container { max-width: none; }

		.prev-1d-container { width: 100%; display: none; }
		.prev-1d-container.visible { display: block; }
		.prev-1d-label { font-size: 14px; color: #aaa; margin-bottom: 4px; }

		body.mode-1d #canvPrev1D {
			position: sticky;
			top: 0;
			z-index: 20;
			background: #111;
			border: 2px solid #08d;
		}

		#canvPrev1D {
			border: 2px solid #08d;
			background: #111;
			width: 100%;
			height: 40px;
			touch-action: none;
			image-rendering: pixelated;
		}

		.wrapped-rows-container { width: 100%; display: none; flex-direction: column; gap: 16px; }
		.wrapped-rows-container.visible { display: flex; }
		.row-canvas-wrapper { width: 100%; cursor: pointer; }
		.row-canvas-wrapper canvas {
			border: 1px solid #666;
			background: #111;
			touch-action: none;
			image-rendering: pixelated;
			display: block;
		}

		#canv {
			border: 2px solid #fff;
			background: #111;
			max-width: 100%;
			max-height: 60vh;
			width: auto;
			height: auto;
			touch-action: none;
		}
		#canv.hidden { display: none; }

		.tools-wrapper { display: flex; flex-direction: column; gap: 16px; }
		#status { padding: 6px 16px; border-radius: 20px; background: #a00; font-size: 14px; }

		.upload-section { margin: 20px 0; padding: 0 4px; }
		.upload-1d { display: none; margin-bottom: 12px; }
		.filename-input { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center; margin-bottom: 12px; }
		.filename-input input[type="text"] { max-width: 200px; padding: 6px 10px; }

		@media (min-aspect-ratio: 4/3) and (min-width: 600px) {
			body:not(.mode-1d) .main-content { flex-direction: row; align-items: flex-start; justify-content: center; gap: 16px; }
			body:not(.mode-1d) .canvas-container { order: 2; margin: 0; max-width: none; flex: 1; min-width: 0; padding: 0; }
			#canv { max-height: 85vh; }
			body:not(.mode-1d) .tools-wrapper { order: 1; width: 300px; flex-shrink: 0; }
			body:not(.mode-1d) .controls-section { flex-direction: row; align-items: center; margin-bottom: 16px; }
			body:not(.mode-1d) .sliders { max-width: none; margin: 0; }
			.tool-btn { font-size: 20px; }
			.tools { row-gap: 4px; column-gap: 8px; }
		}

		@media (pointer: coarse) {
			body.mode-1d .row-canvas-wrapper canvas { height: 40px !important; }
			body.mode-1d #canvPrev1D { height: 50px !important; }
			body.mode-1d .wrapped-rows-container { gap: 20px; }
		}
	</style>
</head>
<body>
	<div style="position:absolute;top:0px;left:10px;font-size:10px;color:#666;">v1.0</div>
	<div class="title">WLED <span class="rb">PIXEL</span> Paint</div>
	<div class="matrix-controls">
		<h3 style="margin-top:20px;">Target Segment</h3>
		<select id="seg"><option value="0" data-w="16" data-h="16">Segment 0 (16x16)</option></select>
		<div class="size-inputs">
			<span class="led-count-1d" style="display:none;">LEDs: </span>
			<input type="number" id="matrixW" value="64">
			<span class="size-sep">&times;</span>
			<input type="number" id="matrixH" value="64">
		</div>
		<div>
			<button onclick="undo()" title="Undo"><span class="action-icon">&#xe967;</span></button>
			<button onclick="clearMatrix()" title="Clear"><span class="action-icon">&#xf00d;</span></button>
			<button onclick="togglePreview()" title="Live Preview" id="status">Preview Off</button>
		</div>
	<div><input type="checkbox" id="frz" checked> Freeze Segment</div>
	</div>
	<div class="main-content">
		<div class="tools-wrapper">
			<div class="controls-section">
				<div id="iroPicker"></div>
				<div class="tools-container">
					<div class="tools" id="tools"></div>
				</div>
			</div>
			<div class="sliders">
				<div class="slider-row">
					<input type="range" id="sizeSlider" min="1" max="10" step="0.1" value="1" class="slider">
					<span class="value" id="brushSizeLabel">1.0</span>
					<label>Size</label>
				</div>
				<div class="slider-row">
					<input type="range" id="hardnessSlider" min="1" max="100" value="100" class="slider">
					<span class="value" id="brushHardnessLabel">100</span>
					<label>Hard</label>
				</div>
			</div>
		</div>
		<div class="canvas-container">
			<div class="prev-1d-container" id="prev1DCont">
				<div class="prev-1d-label">Full Strip</div>
				<canvas id="canvPrev1D"></canvas>
			</div>
		<div class="prev-1d-label">Detail View</div>
			<div class="wrapped-rows-container" id="wrapRowCont"></div>
			<div class="wrapped-canvas-container">
				<canvas id="canv"></canvas>
			</div>
		</div>
	</div>
	<div class="upload-section" id="uploadSect">
	<div class="upload-1d">
		<div class="filename-input">
		<label for="presetName">Preset Name:</label>
		<input type="text" id="presetName" placeholder="mycolors" maxlength="26">
		</div>
		<button class="btn" id="save1D">Save as Preset</button>
	</div>
		<div class="upload-2d">
			<div class="filename-input">
				<label for="fn">Filename:</label>
				<input type="text" id="fn" placeholder="mypaint" maxlength="26">
				<small>.gif</small>
			</div>
			<button class="btn" id="up">Upload gif</button>
		</div>
	</div>
	<div style="text-align:center;margin:20px 0">
		<button class="btn" onclick="window.location.href=wu">Back to Controls</button>
	</div>
	<div style="font-size:12px;color:#666;">by @dedehai</div>
	<script>
		const PIXEL_SIZE = 32, DEFAULT_MATRIX = 64, MIN_MATRIX = 1, MAX_LEDS = 4096, MAX_MATRIX = 128;
		const LED_PX_SIZE = 16, ROW_HEIGHT = 24; // 1D size
		const TOOLS = [
			{name:"Line",    icon: "&#xf068;"},  // minus/draw line f068
			{name:"Rect",    icon: "&#xf096;"},  // square f096
			{name:"Circle",  icon: "&#xf1db;"},  // circle f1db
			{name:"Fill",    icon: "&#xe90b;"},  // fill e90b
			{name:"Pen",     icon: "&#xf1fc;"},  // paintbrush f1fc
			{name:"Smear",   icon: "&#xf25a;"}   // smear hand f25a
		];

		const canv = document.getElementById("canv"), ctx = canv.getContext("2d");
		const canvPrev1D = document.getElementById("canvPrev1D"), ctxPrev1D = canvPrev1D.getContext("2d");
		const mW = document.getElementById("matrixW"), mH = document.getElementById("matrixH");
		const statusEl = document.getElementById("status"), wrapRowCont = document.getElementById("wrapRowCont");
		const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
		let w = DEFAULT_MATRIX, h = DEFAULT_MATRIX, matrix = [], segs = [], curSeg = null;
		let painting = false, tool = 4, startPt = null, lastPos = null, preview = null;
		let iroColor = "#ff6600", iroPicker, brushSize = 1, brushHard = 100;
		let undoStack = [], savedStroke = false;
		let ws = null, prvEn = false, maxColInd = null, prvTmr = null;
		let lastSentMtx = [], wu = '', loc = false, snapMtx = null;
		let is1D = false, wrapW = 50, rowCanv = [], selRow = 0;
		let offCanv = document.createElement('canvas'), offCtx = offCanv.getContext('2d'); // off-screen canvas that hold the actual pixel data
		let globalBri = null;

		const c2h = (r,g,b)=>((r<<16)|(g<<8)|b).toString(16).padStart(6,'0').toUpperCase();
		const h2c = h=>{const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:0,g:0,b:0};};

		// init function, reads current segements and puts them in the select list
		(async()=>{
			wu = `http://${new URLSearchParams(window.location.search).get('host') || window.location.host}`;
			const s1 = document.getElementById('seg');
			try {
				const r = await fetch(`${wu}/json/state`), j = await r.json();
				globalBri = j.bri || 128;
				segs = j.seg || [];
				s1.innerHTML = '';
				if (segs.length) {
					segs.forEach(seg => {
						const {id,n,start,stop,startY,stopY,grp,spc} = seg;
						const o = new Option(n || `Segment ${id}`, id);
						const g = grp || 1, s = spc || 0;
						const physH = stopY - startY;
						o.dataset.w = Math.ceil((stop - start) / (g + s));
						o.dataset.h = physH > 1 ? Math.ceil(physH / (g + s)) : 1;
						o.dataset.segData = JSON.stringify(seg);
						s1.add(o);
					});
				} else {
					const o = new Option('Segment 0', 0);
					o.dataset.w = 16; o.dataset.h = 16;
					o.dataset.segData = JSON.stringify({id:0,start:0,stop:16,len:16,grp:1,spc:0,of:0,on:true,bri:255,bm:0,rev:false});
					s1.add(o);
				}
				const o = s1.options[s1.selectedIndex];
				if (o) { mW.value = o.dataset.w || 16; mH.value = o.dataset.h || 16; updateMatrix(); }
			} catch(e) { console.error(e); }
		})();

		iroPicker = new iro.ColorPicker("#iroPicker", {width:168, color:iroColor, layout:[{component:iro.ui.Wheel},{component:iro.ui.Slider,options:{sliderType:'value'}}]});
		iroPicker.on('color:change', c => iroColor = c.hexString);

		TOOLS.forEach((t,i)=>{
			const btn = document.createElement("button");
			btn.className = "tool-btn" + (i==4?" selected":"") + (i<3?" hide-1d":"");
			btn.innerHTML = t.icon;
			btn.title = t.name;
			btn.onclick = ()=>{
				document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove("selected"));
				btn.classList.add("selected");
				tool = i;
			};
			document.getElementById("tools").appendChild(btn);
		});

		document.getElementById("sizeSlider").oninput = e=>{
			brushSize = parseFloat(e.target.value);
			document.getElementById("brushSizeLabel").textContent = brushSize.toFixed(1);
		};
		document.getElementById("hardnessSlider").oninput = e=>{
			brushHard = +e.target.value;
			document.getElementById("brushHardnessLabel").textContent = brushHard;
		};

		// update if selected segment changes
		document.getElementById('seg').onchange = async e=>{
			const o = e.target.selectedOptions[0];
			mW.value = o.dataset.w; mH.value = o.dataset.h;
			updateMatrix();
			if (prvEn) {
				if (curSeg) await reqJson({seg:{id:curSeg.id,frz:false}});
				const segId = +e.target.value;
				curSeg = segs.find(s=>s.id===segId)||{id:segId,start:0};
				await reqJson({seg:{id:curSeg.id,frz:true}});
				lastSentMtx = new Array(w*h).fill(null);
				await sendDirty();
			}
		};

		function updateMatrix() {
			is1D = +mH.value <= 1;

			if (is1D) {
				w = Math.max(MIN_MATRIX, Math.min(MAX_LEDS, +mW.value));
				h = 1;
				document.body.classList.add('mode-1d');
				mW.disabled = true;
				mH.disabled = true;
				document.getElementById('prev1DCont').classList.add('visible');
				document.querySelectorAll('.prev-1d-label').forEach(e=>e.style.display='block');
				wrapRowCont.classList.add('visible');
				canv.classList.add('hidden');
				canvPrev1D.width = w;
				canvPrev1D.height = 1;
				offCanv.width = w;
				offCanv.height = 1;
				createRowCanv();
			} else {
				w = Math.max(MIN_MATRIX, Math.min(MAX_MATRIX, +mW.value));
				h = Math.max(1, Math.min(MAX_MATRIX, +mH.value));
				mW.value = w; mH.value = h; // input fields
				document.body.classList.remove('mode-1d');
				mW.disabled = false;
				mH.disabled = false;
				document.getElementById('prev1DCont').classList.remove('visible');
				document.querySelectorAll('.prev-1d-label').forEach(e=>e.style.display='none');
				wrapRowCont.classList.remove('visible');
				canv.classList.remove('hidden');
				offCanv.width = w;
				offCanv.height = h;
			}

			canv.width = w * PIXEL_SIZE;
			canv.height = h * PIXEL_SIZE;
			canv.style.aspectRatio = `${w}/${h}`;

			const sz = w * h;
			if (matrix.length != sz) matrix = Array.from({length: sz}, () => ({r:0,g:0,b:0}));
			drawAll();
		}
		mW.onchange = mH.onchange = updateMatrix; // user input: update matrix size

		// create 1D detail painting rows
		function createRowCanv(){
			wrapRowCont.innerHTML='';
			rowCanv=[];	  const contW=(wrapRowCont.offsetWidth||800)-(isTouch?48:0);
			const optW=Math.floor(contW/LED_PX_SIZE);
			wrapW=Math.max(10,Math.min(200,optW));
			const numRows=Math.ceil(mW.value/wrapW);

			for(let ri=0;ri<numRows;ri++){
			const si=ri*wrapW;
			const ei=Math.min(si+wrapW,mW.value);
			const rw=ei-si;

			const wrap=document.createElement('div');
			wrap.className='row-canvas-wrapper';
			if(ri===0)wrap.classList.add('selected');

			const cv=document.createElement('canvas');
			cv.width=rw*LED_PX_SIZE;
			cv.height=LED_PX_SIZE;
			cv.style.width=(rw*LED_PX_SIZE)+'px';
			cv.style.height=ROW_HEIGHT+'px';
			const c=cv.getContext('2d');
			c.imageSmoothingEnabled=false;

			// paint immediately on pointerdown in any row
			cv.onpointerdown=e=>{
				selRow=ri;
				rowCanv.forEach((r,i)=>r.wrap.classList.toggle('selected',i===ri));
				startPaint(e,'row');
			};
			cv.onpointermove=e=>{e.preventDefault();if(painting&&selRow===ri)paint(e,'row');};
			cv.onpointerleave=()=>{preview=lastPos=null;drawAll();};
			wrap.appendChild(cv);
			wrapRowCont.appendChild(wrap);
			rowCanv.push({canv:cv,ctx:c,si,ei,wrap});
			}
			selRow=0;
			drawAll();
		}

		// update detail-rows when window size changes so they always fit
		let resizeTmr;
		window.addEventListener('resize', ()=>{
			if (!is1D) return;
			clearTimeout(resizeTmr);
			resizeTmr = setTimeout(()=>{
				const oldSel = selRow; createRowCanv();
				if (oldSel < rowCanv.length) selRow = oldSel;
			}, 100);
		});

		// coordinate transfrmations to match different canvas sizes
		function getCoord(e,mode){
			if(mode==='1d'){
			const rect=canvPrev1D.getBoundingClientRect();
			const scX=canvPrev1D.width/rect.width;
			const idx=Math.floor((e.clientX-rect.left)*scX);
			return{idx:Math.max(0,Math.min(mW.value-1,idx))};
			}
			if(mode==='row'){
			const row=rowCanv[selRow];
			const rect=row.canv.getBoundingClientRect();
			const clickX=e.clientX-rect.left;
			const rw=row.ei-row.si;
			const px=Math.floor((clickX/rect.width)*rw);
			return{idx:row.si+Math.max(0,Math.min(rw-1,px))};
			}
			const rect=canv.getBoundingClientRect(),scX=canv.width/rect.width,scY=canv.height/rect.height;
			return{x:Math.floor((e.clientX-rect.left)*scX/PIXEL_SIZE),y:Math.floor((e.clientY-rect.top)*scY/PIXEL_SIZE)};
		}

		function drawAll() {
			if (is1D) {
				offCtx.fillStyle = "#111"; offCtx.fillRect(0,0,w,1);
				for (let i=0;i<w;i++){const c=matrix[i];offCtx.fillStyle=`rgb(${c.r},${c.g},${c.b})`;offCtx.fillRect(i,0,1,1);}
				ctxPrev1D.imageSmoothingEnabled=false;
				ctxPrev1D.drawImage(offCanv,0,0,canvPrev1D.width,canvPrev1D.height);
				rowCanv.forEach(r=>{
					const c=r.ctx,cv=r.canv; c.fillStyle="#111"; c.fillRect(0,0,cv.width,cv.height);
					for(let i=r.si;i<r.ei;i++){const col=matrix[i];c.fillStyle=`rgb(${col.r},${col.g},${col.b})`;c.fillRect((i-r.si)*LED_PX_SIZE,0,LED_PX_SIZE,cv.height);}
					c.strokeStyle='#666'; c.lineWidth=1; c.beginPath();
					for(let i=1;i<(r.ei-r.si);i++){const x=i*LED_PX_SIZE; c.moveTo(x,0); c.lineTo(x,cv.height);}
					c.stroke();
				});
				return;
			}
			offCtx.fillStyle="#111"; offCtx.fillRect(0,0,w,h);
			const imgData=offCtx.createImageData(w,h);
			const data=imgData.data;
			for(let i=0;i<w*h;i++){
				const c=matrix[i];
				const idx=i*4;
				data[idx]=c.r;
				data[idx+1]=c.g;
				data[idx+2]=c.b;
				data[idx+3]=255;
			}
			offCtx.putImageData(imgData,0,0);

			ctx.imageSmoothingEnabled=false; ctx.drawImage(offCanv,0,0,canv.width,canv.height);
			if(preview){ctx.strokeStyle='rgba(255,255,255,0.8)';ctx.lineWidth=Math.max(1,brushSize*PIXEL_SIZE/4);
				const sx=preview.start.x*PIXEL_SIZE+PIXEL_SIZE/2, sy=preview.start.y*PIXEL_SIZE+PIXEL_SIZE/2;
				const ex=preview.end.x*PIXEL_SIZE+PIXEL_SIZE/2, ey=preview.end.y*PIXEL_SIZE+PIXEL_SIZE/2;
				ctx.beginPath();
				if(preview.tool===0){ctx.moveTo(sx,sy);ctx.lineTo(ex,ey);}
				else if(preview.tool===1){const x1=Math.min(sx,ex),y1=Math.min(sy,ey);ctx.rect(x1,y1,Math.max(sx,ex)-x1,Math.max(sy,ey)-y1);}
				else if(preview.tool===2){ctx.ellipse((sx+ex)/2,(sy+ey)/2,Math.abs(ex-sx)/2,Math.abs(ey-sy)/2,0,0,2*Math.PI);}
				ctx.stroke();
			}
			ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1; ctx.beginPath();
			for(let i=1;i<w;i++){const px=i*PIXEL_SIZE;ctx.moveTo(px,0);ctx.lineTo(px,canv.height);}
			for(let j=1;j<h;j++){const py=j*PIXEL_SIZE;ctx.moveTo(0,py);ctx.lineTo(canv.width,py);}
			ctx.stroke();
		}

		function setPx(x,y,col,op=1,draw=true){
			if(x<0||x>=w||y<0||y>=h)return;
			const i=y*w+x,o=matrix[i];
			matrix[i]={r:Math.round((1-op)*o.r+op*col.r),g:Math.round((1-op)*o.g+op*col.g),b:Math.round((1-op)*o.b+op*col.b)};
			if(draw)drawAll();
		}

		function getPx(x,y){
			return matrix[Math.max(0,Math.min(h-1,y))*w+Math.max(0,Math.min(w-1,x))];
		}

		function colorDist(c1,c2){
			const dr=c1.r-c2.r,dg=c1.g-c2.g,db=c1.b-c2.b;
			return Math.sqrt(dr*dr+dg*dg+db*db);
		}

		function saveState(){
			undoStack.push(matrix.map(c=>({r:c.r,g:c.g,b:c.b})));
			if(undoStack.length>50)undoStack.shift(); // fixed undo stack size of 50 to not use excessive RAM on the device
		}

		function undo(){
			if(undoStack.length){
			matrix=undoStack.pop();
			drawAll();
			if(prvEn) sendDirty();
			}
		}

		function applyBrush(x,y,col,draw=true){
			const rad=Math.ceil(brushSize);
			const mult=brushHard<=50?(brushHard/50)*0.5:0.5+((brushHard-50)/50)*0.5;
			if(is1D){
			const idx=y*w+x;
			for(let di=-rad;di<=rad;di++){
				const d=Math.abs(di);
				if(d>brushSize)continue;
				const i=idx+di;
				if(i<0||i>=mW.value)continue;
				const fall=1-d/brushSize;
				const o=matrix[i];
				const op=fall*mult;
				matrix[i]={r:Math.round((1-op)*o.r+op*col.r),g:Math.round((1-op)*o.g+op*col.g),b:Math.round((1-op)*o.b+op*col.b)};
			}
			}else{
			for(let dx=-rad;dx<=rad;dx++){
				for(let dy=-rad;dy<=rad;dy++){
				const d=Math.sqrt(dx*dx+dy*dy);
				if(d>brushSize)continue;
				const fall=1-d/brushSize;
				setPx(x+dx,y+dy,col,fall*mult,false);
				}
			}
			}
			if(draw)drawAll();
		}

		function clearMatrix(){
			matrix=Array.from({length:w*h},()=>({r:0,g:0,b:0}));
			drawAll();
			if(prvEn) sendDirty(); // send full frame update
		}

		// toggle live preview on LEDs
		async function togglePreview(){
			prvEn=!prvEn;
			statusEl.textContent=prvEn?"Preview On":"Preview Off";
			statusEl.style.background=prvEn?"#08d":"#a00";
			if(prvEn){
			reqJson({seg:{frz:true}});
			initWS();
			lastSentMtx=new Array(w*h).fill(null);
			const segId=+document.getElementById('seg').value;
			curSeg=segs.find(s=>s.id===segId)||{id:segId,start:0};
			await sendDirty(); // send full frame
			}else{
			reqJson({seg:{frz:false}});
			if(prvTmr)clearTimeout(prvTmr);
			prvTmr=curSeg=null;
			}
		}

		function startPaint(e,mode){
			e.preventDefault();
			painting=true;
			const coord=getCoord(e,mode);
			startPt=lastPos=coord;
			savedStroke=false;
			snapMtx=matrix.map(c=>({r:c.r,g:c.g,b:c.b}));
			paint(e,mode);
			if(prvEn&&!prvTmr)paintCmp(); // start scheduler to monitor pixel changes and send them out
		}

		canv.addEventListener('pointerdown',e=>startPaint(e,'2d'));
		canv.addEventListener('pointermove',e=>{e.preventDefault();if(painting)paint(e,'2d');});
		canv.addEventListener('pointerleave',()=>{preview=lastPos=null;drawAll();});

		canvPrev1D.addEventListener('pointerdown',e=>startPaint(e,'1d'));
		canvPrev1D.addEventListener('pointermove',e=>{e.preventDefault();if(painting)paint(e,'1d');});
		canvPrev1D.addEventListener('pointerleave',()=>{lastPos=null;drawAll();});

		document.addEventListener('pointerup',endPaint);

		async function endPaint(){
			const wasPaint=painting;
			if(painting&&preview&&!is1D){
			saveState();
			const col=h2c(iroColor);
			if(preview.tool===0)applyLine(preview.start.x,preview.start.y,preview.end.x,preview.end.y,col);
			else if(preview.tool===1)applyRect(preview.start.x,preview.start.y,preview.end.x,preview.end.y,col);
			else if(preview.tool===2)applyCircle(preview.start.x,preview.start.y,preview.end.x,preview.end.y,col);
			preview=null;
			drawAll();
			}
			painting=false;
			startPt=lastPos=null;
			savedStroke=false;
			if(wasPaint&&prvEn){
			setTimeout(async()=>{
				const diff=[];
				for(let i=0;i<matrix.length;i++){
				const o=snapMtx[i],n=matrix[i];
				if(o.r!==n.r||o.g!==n.g||o.b!==n.b)diff.push({idx:i,hex:c2h(n.r,n.g,n.b)});
				}
				if(diff.length)await sendDirty(diff); // first pass: send diff between now and before painting
			},80); // let the paint dry first ;)
			setTimeout(async()=>{
				await sendDirty(); // second pass: update the full frame in case something went wrong
			},300);
			}
		}

		function paint(e,mode){
			const coord=getCoord(e,mode);
			const col=h2c(iroColor);
			const px=coord.idx!==undefined?coord.idx%w:coord.x;
			const py=coord.idx!==undefined?Math.floor(coord.idx/w):coord.y;

			switch(tool){
			case 0:
			case 1:
			case 2:
				if(startPt&&!is1D){preview={tool,start:startPt,end:coord};drawAll();}
				break;
			case 3:
				saveState();
				floodFill(px,py,col);
				break;
			case 4:
				if(!savedStroke){saveState();savedStroke=true;}
				if(lastPos){
				const lx=lastPos.idx!==undefined?lastPos.idx%w:lastPos.x;
				const ly=lastPos.idx!==undefined?Math.floor(lastPos.idx/w):lastPos.y;
				if(lx!==px||ly!==py){
					const dx=px-lx,dy=py-ly,steps=Math.max(1,Math.ceil(Math.sqrt(dx*dx+dy*dy)));
					for(let i=0;i<=steps;i++)applyBrush(Math.round(lx+dx*i/steps),Math.round(ly+dy*i/steps),col,false);
					drawAll();
				}else applyBrush(px,py,col);
				}else applyBrush(px,py,col);
				lastPos=coord;
				break;
			case 5:
				if(!savedStroke){saveState();savedStroke=true;}
				if(lastPos){
				const lx=lastPos.idx!==undefined?lastPos.idx%w:lastPos.x;
				const ly=lastPos.idx!==undefined?Math.floor(lastPos.idx/w):lastPos.y;
				if(lx!==px||ly!==py){
					const dx=px-lx,dy=py-ly,steps=Math.max(1,Math.ceil(Math.sqrt(dx*dx+dy*dy)));
					const rad=Math.ceil(brushSize);
					for(let i=0;i<=steps;i++){
					const cx=Math.round(lx+dx*i/steps),cy=Math.round(ly+dy*i/steps);
					for(let ddx=-rad;ddx<=rad;ddx++){
						for(let ddy=-rad;ddy<=rad;ddy++){
						const d=Math.sqrt(ddx*ddx+ddy*ddy);
						if(d>brushSize)continue;
						const op=(1-d/brushSize)*(0.3+brushHard/100*0.7);
						setPx(cx+ddx,cy+ddy,getPx(lx+ddx,ly+ddy),op,false);
						}
					}
					}
					drawAll();
				}
				}
				lastPos=coord;
				break;
			}
		}

		function applyLine(x0,y0,x1,y1,col){
			let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0),sx=x0<x1?1:-1,sy=y0<y1?1:-1,err=dx-dy;
			while(true){
			applyBrush(x0,y0,col,false);
			if(x0==x1&&y0==y1)break;
			const e2=2*err;
			if(e2>-dy){err-=dy;x0+=sx;}
			if(e2<dx){err+=dx;y0+=sy;}
			}
			drawAll();
		}

		function floodFill(x,y,col){
			const thresh=(brushSize/10)*25,tgt=getPx(x,y);
			if(colorDist(tgt,col)<thresh)return;
			let vis=new Uint8Array(w*h),stack=[[x,y]];
			while(stack.length){
			let[cx,cy]=stack.pop();
			if(cx<0||cx>=w||cy<0||cy>=h)continue;
			let i=cy*w+cx;
			if(vis[i])continue;
			vis[i]=1;
			if(colorDist(getPx(cx,cy),tgt)>thresh)continue;
			setPx(cx,cy,col,brushHard/100,false);
			stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
			}
			drawAll();
		}

		function applyRect(x0,y0,x1,y1,col){
			let xmin=Math.min(x0,x1),xmax=Math.max(x0,x1),ymin=Math.min(y0,y1),ymax=Math.max(y0,y1);
			for(let x=xmin;x<=xmax;x++){applyBrush(x,ymin,col,false);applyBrush(x,ymax,col,false);}
			for(let y=ymin+1;y<ymax;y++){applyBrush(xmin,y,col,false);applyBrush(xmax,y,col,false);}
			drawAll();
		}

		function applyCircle(x0,y0,x1,y1,col){
			const cx=(x0+x1)/2,cy=(y0+y1)/2,rx=Math.abs(x1-x0)/2,ry=Math.abs(y1-y0)/2;
			const steps=Math.max(300,Math.ceil(2*Math.PI*Math.max(rx,ry)));
			for(let i=0;i<steps;i++){
			const a=(i/steps)*2*Math.PI;
			applyBrush(Math.round(cx+rx*Math.cos(a)),Math.round(cy+ry*Math.sin(a)),col,false);
			}
			drawAll();
		}

		function initWS(){
			if(!ws||ws.readyState!==WebSocket.OPEN)ws=connectWs();
			fetch(`${wu}/json/info`).then(r=>r.json()).then(inf=>{
			maxColInd=inf.arch==='esp8266'?35:85; // maxColInd is the maximum individual color commands that fit in WS buffer (~12 bytes per color, conservative estimate)
			}).catch(()=>{});
			if(!ws)maxColInd=256;
		}

		function connectWs(){
			try{if(top.window.ws&&top.window.ws.readyState===WebSocket.OPEN)return top.window.ws;}catch(e){}
			let url=(loc?`${wu}/ws`.replace("http","ws"):"ws://"+window.location.hostname+"/ws");
			let w=new WebSocket(url);
			w.binaryType="arraybuffer";
			w.addEventListener('close',()=>ws=null);
			w.addEventListener('error',()=>ws=null);
			return w;
		}

		// send json request over WS or HTTP
		async function reqJson(cmd){
			if(ws&&ws.readyState==1){
			try{ws.send(JSON.stringify(cmd));return 1;}catch(e){}
			}
			if(!window._httpQ){window._httpQ=[];window._httpRun=0;}
			if(_httpQ.length>=5)return -1;
			return new Promise(resolve=>{
			_httpQ.push({cmd,resolve});
			(async function run(){
				if(_httpRun)return;
				_httpRun=1;
				while(_httpQ.length){
				let q=_httpQ.shift();
				try{await fetch(`${wu}/json`,{method:'post',body:JSON.stringify(q.cmd),cache:'no-store'});}catch(e){}
				await new Promise(r=>setTimeout(r,120));
				q.resolve(0);
				}
				_httpRun=0;
			})();
			});
		}

		// sends out the pixels contained in the diffList in chunks, sends full frame update when no diffList provided
		async function sendDirty(diffList){
			if(!prvEn||!curSeg)return;
			let interval=20,isRefresh=false;
			if(!diffList){
			diffList=matrix.map((c,i)=>({idx:i,hex:c2h(c.r,c.g,c.b)}));
			interval=40;
			isRefresh=true;
			}
			if(!diffList.length)return;
			diffList.sort((a,b)=>a.idx-b.idx);
			let chunk=[];
			for(let d of diffList){
			if(d.idx>=matrix.length)continue;
			chunk.push((curSeg.start||0)+d.idx,d.hex);
			if(chunk.length>=maxColInd*2){
				if(isRefresh&&painting)return;
				await reqJson({seg:{id:curSeg.id,i:chunk}});
				chunk=[];
				await new Promise(r=>setTimeout(r,interval));
			}
			}
			if(chunk.length){
			await reqJson({seg:{id:curSeg.id,i:chunk}});
			await new Promise(r=>setTimeout(r,interval));
			}
			for(let d of diffList){
			if(d.idx<matrix.length)lastSentMtx[d.idx]=d.hex;
			}
		}

		// monitoring loop that checks for changed pixels while painting every 50ms
		function paintCmp(){
			prvTmr=setTimeout(async()=>{
			prvTmr=null;
			const diff=[];
			for(let i=0;i<matrix.length;i++){
				const c=matrix[i];
				const hex=c2h(c.r,c.g,c.b);
				if(lastSentMtx[i]!==hex)diff.push({idx:i,hex});
			}
			if(diff.length)await sendDirty(diff);
			if(painting&&prvEn)paintCmp();
			},50);
		}


		async function save1DPreset(){
			const fn=document.getElementById('presetName').value.trim()||'paint';
			if(!fn)return;

			// build color array and optimize size using range pattern
			const colors=matrix.slice(0,mW.value).map(c=>c2h(c.r,c.g,c.b));
			const pattern=[];
			let si=0,cur=colors[0];
			for(let i=1;i<=colors.length;i++){
			if(i===colors.length||colors[i]!==cur){
				pattern.push(...(i-si===1?[cur]:[si,i,cur]));
				if(i<colors.length){si=i;cur=colors[i];}
			}
			}
			// get current segment info
			const segSel=document.getElementById('seg');
			const segOpt=segSel.selectedOptions[0];
			const segData=JSON.parse(segOpt.dataset.segData||'{}');

			try{
			// get next availabe preset ID
			const presets=await(await fetch(`${wu}/presets.json`)).json();
			const ids=Object.keys(presets).map(k=>parseInt(k)).filter(n=>!isNaN(n));
			const nextId=ids.length?Math.max(...ids)+1:1;

			// save preset with segment settings needed for static display "as it was" when painting
			const res=await(await fetch(`${wu}/json`,{
				method:'POST',
				body:JSON.stringify({
				on:true,
				bri:globalBri,
				seg:{
					id:segData.id||0,
					start:segData.start||0,
					stop:segData.stop||mW.value,
					len:segData.len||mW.value,
					grp:segData.grp||1,
					spc:segData.spc||0,
					of:segData.of||0,
					on:true,
					frz:true,
					bri:segData.bri||255,
					bm:segData.bm||0,
					rev:segData.rev||false,
					i:pattern
				},
				n:fn,
				o:false, // tell WLED to use the data provided for preset saving instead of applying and then saving (which does not work with "i" content)
				psave:nextId
				})
			})).json();

			if(res.success){
				showToast(`Preset "${fn}" saved as ID ${nextId}\n${pattern.length} elements (${colors.length} LEDs)`);
			}else showToast('Failed to save preset');
			}catch(e){
			const preset={on:true,bri:globalBri,seg:{id:segData.id||0,start:segData.start||0,stop:segData.stop||mW.value,len:segData.len||mW.value,grp:segData.grp||1,spc:segData.spc||0,of:segData.of||0,on:true,frz:true,bri:segData.bri||255,bm:segData.bm||0,rev:segData.rev||false,i:pattern},n:fn,o:false};
			const a=document.createElement('a');
			a.href=URL.createObjectURL(new Blob([JSON.stringify(preset,null,2)],{type:'application/json'}));
			a.download=`${fn.replace(/[^a-z0-9]/gi,'_')}.json`;
			a.click();
			URL.revokeObjectURL(a.href);
			showToast('Could not connect to WLED. Downloaded as file.');
			}
		}
		document.getElementById('save1D').onclick=save1DPreset;

		// generate gif palette by reducing bit depth until it fits 256 colors
		function genPal(pix){
			let mask=0xFF;
			while(true){
			const map=new Map(),idx=new Uint8Array(pix.length/4),pal=[];
			let over=false;
			for(let i=0,j=0;i<pix.length;i+=4,j++){
				const r=pix[i]&mask,g=pix[i+1]&mask,b=pix[i+2]&mask,key=`${r},${g},${b}`;
				if(!map.has(key)){
				map.set(key,map.size);
				pal.push((r<<16)|(g<<8)|b);
				if(map.size>256){over=true;break;}
				}
				idx[j]=map.get(key);
			}
			if(!over)return{indexed:idx,palette:pal};
			mask&=(mask<<1)&0xFF;
			if(mask===0)return{indexed:idx,palette:pal.slice(0,256)};
			}
		}

		// add padding to pallete (conform with gif standard)
		function palPad(pal){
			let p2=1;
			while(p2<pal.length)p2<<=1;
			while(pal.length<p2)pal.push(pal[pal.length-1]);
			return pal;
		}

		// generate and upload gif
		document.getElementById('up').onclick=async()=>{
			const fn=document.getElementById('fn').value.trim()||'mypainting',filename=`${fn}.gif`;
			let exists=false;
			try{
			const r=await fetch(`${wu}/edit?list=/`),data=await r.json();
			exists=data.some(f=>f.name==="/"+filename&&f.name.toLowerCase().endsWith('.gif'));
			}catch(e){console.error('Error fetching file list:',e);}
			if(exists&&!confirm(`${filename} already exists. Do you want to overwrite it?`))return;
			try{
			const pix=new Uint8Array(w*h*4);
			for(let i=0;i<w*h;i++){
				const c=matrix[i];
				pix[i*4]=c.r;pix[i*4+1]=c.g;pix[i*4+2]=c.b;pix[i*4+3]=255;
			}
			const id=new ImageData(new Uint8ClampedArray(pix),w,h);
			let{indexed,palette}=genPal(id.data);
			palette=palPad(palette);
			const gifData=[],wr=new window.GifWriter(gifData,w,h,{loop:0});
			wr.addFrame(0,0,w,h,indexed,{palette});
			wr.end();
			const fU=new File([new Uint8Array(gifData)],filename,{type:'image/gif'});
			const fd=new FormData();
			fd.append('file',fU,filename);
			const r=await fetch(`${wu}/upload`,{method:'POST',body:fd});
			if(r.ok)showToast(`${filename} uploaded`);
			else showToast('Upload failed');
			}catch(e){showToast(`Error: ${e.message}`);}
		};

		// unfreeze segment when leaving the page unless freeze checkbox is checked
		window.addEventListener('beforeunload',()=>{
			if(prvEn && !document.getElementById('frz').checked) reqJson({seg:{frz:false}});
		});

		function showToast(message) {
			const toast = document.createElement('div');
			Object.assign(toast.style, {
			position: 'fixed', bottom: '20px', right: '20px',
			background: '#555', color: '#fff', padding: '10px 20px',
			borderRadius: '10px', fontSize: '14px', zIndex: '1000'
			});
			toast.textContent = message;
			document.body.appendChild(toast);
			setTimeout(() => toast.remove(), 4000);
		}

		updateMatrix();
		togglePreview(); // enable preview on page load
	</script>
</body>
</html>